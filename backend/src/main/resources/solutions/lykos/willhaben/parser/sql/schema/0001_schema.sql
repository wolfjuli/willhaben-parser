CREATE TABLE schema_version
(
    patch_level      SMALLINT NOT NULL
        PRIMARY KEY,
    patch_file       TEXT,
    created_datetime TIMESTAMP WITH TIME ZONE DEFAULT current_timestamp
);


CREATE TABLE watch_lists
(
    id  INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    url TEXT NOT NULL
        UNIQUE
);


CREATE TABLE listings
(
    id               INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    created_datetime TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    last_seen        TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    willhaben_id     INTEGER                                NOT NULL,
    hash             TEXT                                   NOT NULL
        UNIQUE,
    duplicate_hash   TEXT                                   NOT NULL,
    raw              JSONB                                  NOT NULL
);


CREATE INDEX listings_duplicate_hash_idx
    ON willhaben.listings (duplicate_hash);

CREATE INDEX listings_last_seen_idx
    ON willhaben.listings (last_seen);

CREATE INDEX listings_willhaben_id_idx
    ON willhaben.listings (willhaben_id);

CREATE TABLE listing_user_attributes
(
    listing_id   INTEGER NOT NULL REFERENCES listings ON UPDATE CASCADE ON DELETE CASCADE,
    attribute_id INTEGER NOT NULL REFERENCES attributes (id) ON DELETE CASCADE ON UPDATE CASCADE,
    values       JSONB,
    PRIMARY KEY (listing_id, attribute_id)
);


CREATE TABLE functions
(
    id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    function TEXT NOT NULL,
    name     TEXT
);


CREATE TABLE scripts
(
    id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_id SMALLINT NOT NULL REFERENCES attributes (id) ON DELETE CASCADE ON UPDATE CASCADE,
    name         TEXT
);


CREATE TABLE script_functions
(
    script_id   SMALLINT NOT NULL
        REFERENCES scripts
            ON UPDATE CASCADE ON DELETE CASCADE,
    function_id SMALLINT NOT NULL
        REFERENCES functions
            ON UPDATE CASCADE ON DELETE CASCADE,
    ord         SMALLINT NOT NULL,
    PRIMARY KEY (script_id, function_id, ord)
);


CREATE TABLE listing_points
(
    listing_id   INTEGER  NOT NULL
        REFERENCES listings
            ON UPDATE CASCADE ON DELETE CASCADE,
    attribute_id SMALLINT NOT NULL,
    script_id    SMALLINT NOT NULL
        REFERENCES scripts
            ON UPDATE CASCADE ON DELETE CASCADE,
    points       DOUBLE PRECISION,
    PRIMARY KEY (listing_id, attribute_id, script_id)
);


CREATE INDEX listing_points_points_idx
    ON willhaben.listing_points (points);

CREATE TABLE attributes
(
    id        SERIAL PRIMARY KEY,
    attribute TEXT NOT NULL UNIQUE,
    label     TEXT,
    data_type DATA_TYPE
);


CREATE TABLE custom_attributes
(
    id          INTEGER  NOT NULL PRIMARY KEY REFERENCES attributes ON UPDATE CASCADE ON DELETE CASCADE,
    function_id SMALLINT NOT NULL REFERENCES functions ON UPDATE CASCADE ON DELETE CASCADE,
    data_type   DATA_TYPE NOT NULL
);


CREATE MATERIALIZED VIEW willhaben.duplicate_listings AS
SELECT c.id            AS listing_id,
       array_agg(s.id) AS sibblings
FROM listings c
         JOIN listings s
              ON c.duplicate_hash = s.duplicate_hash
GROUP BY c.id;


CREATE VIEW folded_scripts(script_id, attribute_id, script) AS
SELECT script_id,
       attribute_id,
       ((((('(v, r) => {'::TEXT || funs) || ' return '::TEXT) || folded) || 'v'::TEXT) ||
        repeat(', r)'::TEXT, count::INTEGER)) || '; }'::TEXT AS script
FROM (SELECT s.id                                                                          AS script_id,
             s.attribute_id,
             count(*)                                                                      AS count,
             string_agg(DISTINCT ((('const fun'::TEXT || f.id) || ' = '::TEXT) || f.function) || '; '::TEXT,
                        ''::TEXT)                                                          AS funs,
             string_agg(('fun'::TEXT || f.id) || '('::TEXT, ''::TEXT ORDER BY sf.ord DESC) AS folded
      FROM scripts s
               JOIN script_functions sf
                    ON s.id = sf.script_id
               JOIN functions f
                    ON sf.function_id = f.id
      GROUP BY s.id, s.attribute_id) x;


CREATE VIEW fe_configuration(image_base_url, listings_base_url) AS
SELECT 'https://cache.willhaben.at/mmo'::TEXT AS image_base_url,
       'https://www.willhaben.at/iad/'::TEXT  AS listings_base_url;

DROP VIEW IF EXISTS normalized_listings;
CREATE VIEW normalized_listings(listing_id, willhaben_id, listing, md5) AS
WITH RECURSIVE
    ca AS (SELECT l_1.id                                                                                       AS listing_id,
                  jsonb_object_agg(a.attribute,
                                   run_function(f.function, a.attribute, jsonb_build_object('base', l_1.raw))) AS raw
           FROM listings l_1
                    CROSS JOIN custom_attributes ca_1
                    JOIN attributes a
                         ON a.id = ca_1.id
                    JOIN functions f
                         ON f.id = ca_1.function_id
           GROUP BY l_1.id),
    attr_raw AS (SELECT lua.listing_id,
                        a.id AS attribute_id,
                        s.idx,
                        s.part,
                        lua.values
                 FROM listing_user_attributes lua
                          JOIN attributes a
                               ON a.id = lua.attribute_id
                          CROSS JOIN unnest(regexp_split_to_array(a.attribute, '\.')) WITH ORDINALITY s(part, idx)),
    direct_parents AS (SELECT r.listing_id, p.part AS parent, r.part, r.idx, r.values
                       FROM attr_raw r
                                LEFT JOIN attr_raw p
                                          ON p.listing_id = r.listing_id
                                              AND p.attribute_id = r.attribute_id
                                              AND p.idx = r.idx - 1),
    r_ua AS (SELECT r.listing_id, r.parent, r.idx, jsonb_object_agg(r.part, r.values) AS obj
             FROM direct_parents r
                      JOIN (SELECT x.listing_id, x.parent, max(x.idx) AS idx FROM direct_parents x GROUP BY 1, 2) x
                           USING (listing_id, parent, idx)
             GROUP BY r.listing_id, r.parent, r.idx


             UNION ALL

             SELECT r.listing_id, r.parent, r.idx, jsonb_build_object(r.part, r_ua.obj) AS obj
             FROM r_ua
                      JOIN direct_parents r
                           ON r.listing_id = r_ua.listing_id
                               AND r.part = r_ua.parent
                               AND r.idx = r_ua.idx - 1),
    ua AS (SELECT DISTINCT listing_id, obj AS raw
           FROM r_ua
           WHERE idx = 1)
SELECT l.id                                                                           AS listing_id,
       l.willhaben_id,
       jsonb_build_object('base', l.raw, 'custom', ca.raw, 'user', ua.raw)            AS listing,
       md5(jsonb_build_object('base', l.raw, 'custom', ca.raw, 'user', ua.raw)::TEXT) AS md5
FROM listings l
         LEFT JOIN ca
                   ON l.id = ca.listing_id
         LEFT JOIN ua
                   ON l.id = ua.listing_id;


CREATE FUNCTION get_id() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
DECLARE
    new_id SMALLINT;
BEGIN
    WITH existing AS (SELECT id
                      FROM attributes
                      WHERE attribute = new.attribute),
         ins AS (
             INSERT INTO attribute_mapping SELECT
                                           WHERE NOT exists (SELECT FROM existing)
                 RETURNING id)
    SELECT id
    INTO new_id
    FROM (SELECT id FROM existing UNION ALL SELECT id FROM ins) x;

    new.id := new_id;
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION update_listing_points(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                      attribute_ids SMALLINT[] DEFAULT NULL::SMALLINT[],
                                      listing_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                      script_ids SMALLINT[] DEFAULT NULL::SMALLINT[])
    RETURNS LISTING_POINTS
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        INSERT INTO listing_points (listing_id, attribute_id, script_id, points)
            SELECT listing_id,
                   attribute_id,
                   s.id,
                   run_script(s.id, listing_id)
            FROM normalized_listings l
                     CROSS JOIN scripts s
            WHERE (willhaben_ids IS NULL OR
                   listing_id IN (SELECT id FROM listings WHERE willhaben_id = ANY (willhaben_ids)))
              AND (listing_ids IS NULL OR listing_id = ANY (listing_ids))
              AND (attribute_ids IS NULL OR attribute_id = ANY (attribute_ids))
              AND (script_ids IS NULL OR s.id = ANY (script_ids))
            ON CONFLICT (listing_id, attribute_id, script_id) DO UPDATE SET points = excluded.points
            RETURNING listing_id, attribute_id, script_id, points;
END;
$$;


CREATE FUNCTION changed_listing_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION change_listing_custom_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_normalize_listings(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_normalized_listings() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);

END;
$$;


CREATE FUNCTION changed_user_defined_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_script_functions() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(script_ids := ARRAY [coalesce(new.script_id, old.script_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_custom_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(attribute_ids := ARRAY [coalesce(new.id, old.id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_functions() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(function_ids := ARRAY [coalesce(new.id, old.id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION toggle_triggers(action TEXT, namespace TEXT DEFAULT 'willhaben'::TEXT) RETURNS VOID
    LANGUAGE plpgsql
AS
$$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT c.relname, t.tgname
             FROM pg_namespace n
                      JOIN pg_class c
                           ON c.relnamespace = n.oid
                      JOIN pg_trigger t
                           ON t.tgrelid = c.oid
             WHERE n.nspname = namespace
               AND t.tgname LIKE 'trg_changed%'
        LOOP
            EXECUTE format('alter table %I.%I %s trigger %s', namespace, r.relname, action, r.tgname);
        END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION run_script_steps(_script_id SMALLINT, _listing_id INTEGER)
    RETURNS TABLE
            (
                SCRIPT_ID   SMALLINT,
                LISTING_ID  INTEGER,
                FUNCTION_ID INTEGER,
                VALUE       JSONB,
                ORD         SMALLINT
            )
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY WITH RECURSIVE
                     sfs AS (SELECT s.id AS script_id, -s.attribute_id AS function_id, 0 AS ord
                             FROM scripts s

                             UNION ALL

                             SELECT sf.script_id, sf.function_id, sf.ord
                             FROM script_functions sf),
                     fs AS (SELECT -a.id                                                AS function_id,
                                   'listing_path_query(row, ''' || a.attribute || ''')' AS function,
                                   'Get value ' || a.attribute                          AS name,
                                   NULL                                                 AS value
                            FROM attributes a

                            UNION ALL

                            SELECT id, function, name, NULL
                            FROM functions),
                     intermediate AS (SELECT sfs.script_id,
                                             run_function(fs.function, '', l.listing) AS value,
                                             fs.function_id,
                                             l.listing,
                                             sfs.ord
                                      FROM normalized_listings l
                                               JOIN sfs
                                                    ON l.listing_id = _listing_id
                                                        AND sfs.script_id = _script_id
                                                        AND sfs.ord = 0
                                               JOIN fs
                                                    ON sfs.function_id = fs.function_id

                                      UNION ALL

                                      SELECT sfs.script_id,
                                             run_function(fs.function, i.value::TEXT, listing) AS value,
                                             fs.function_id,
                                             i.listing,
                                             sfs.ord
                                      FROM intermediate i
                                               JOIN sfs
                                                    ON sfs.script_id = i.script_id
                                                        AND sfs.ord = i.ord + 1
                                               JOIN fs
                                                    ON sfs.function_id = fs.function_id)
                 SELECT _script_id, _listing_id, i.function_id, i.value, i.ord::SMALLINT
                 FROM intermediate i;
END;
$$;

CREATE OR REPLACE FUNCTION run_script(_script_id SMALLINT, _listing_id INTEGER) RETURNS JSONB
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
DECLARE
    res JSONB;
BEGIN

    WITH maxs AS (SELECT max(ord) AS ord, sf.script_id
                  FROM script_functions sf
                  WHERE sf.script_id = _script_id
                  GROUP BY sf.script_id)
    SELECT rs.value
    INTO res
    FROM run_script_steps(_script_id, _listing_id) rs
             JOIN maxs m
                  ON rs.script_id = m.script_id
                      AND rs.ord = m.ord;

    RETURN res;

END;
$$;

CREATE OR REPLACE FUNCTION run_function(_function TEXT, attribute TEXT, listing JSONB) RETURNS JSONB
    LANGUAGE plpgsql
AS
$$
DECLARE
    res JSONB;
    sql TEXT ;
BEGIN
    sql := 'SELECT to_jsonb(' || _function || ') from (values(''' || coalesce(attribute, '') || ''', ''' ||
           listing::TEXT ||
           '''::JSONB)) r(val, row)';
    EXECUTE sql INTO res;
    RETURN res;
END;
$$;


CREATE FUNCTION run_function(function_id SMALLINT, attribute TEXT, listing JSONB) RETURNS JSONB
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN run_function((SELECT function FROM functions WHERE id = function_id), attribute, listing);
END;
$$;


CREATE OR REPLACE FUNCTION update_listing_points(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 attribute_ids SMALLINT[] DEFAULT NULL::SMALLINT[],
                                                 listing_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 script_ids SMALLINT[] DEFAULT NULL::SMALLINT[])
    RETURNS TABLE
            (
                "like" LISTING_POINTS
            )
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        INSERT INTO listing_points (listing_id, attribute_id, script_id, points)
            SELECT listing_id,
                   attribute_id,
                   s.id,
                   run_script(s.id, listing_id)::TEXT::DOUBLE PRECISION
            FROM normalized_listings l
                     CROSS JOIN scripts s
            WHERE (willhaben_ids IS NULL OR
                   listing_id IN (SELECT id FROM listings WHERE willhaben_id = ANY (willhaben_ids)))
              AND (listing_ids IS NULL OR listing_id = ANY (listing_ids))
              AND (attribute_ids IS NULL OR attribute_id = ANY (attribute_ids))
              AND (script_ids IS NULL OR s.id = ANY (script_ids))
            ON CONFLICT (listing_id, attribute_id, script_id) DO UPDATE SET points = excluded.points
            RETURNING listing_id, attribute_id, script_id, points;
END;
$$;


CREATE FUNCTION listing_path_query(listing JSONB, path TEXT) RETURNS JSONB
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
DECLARE
    ret JSONB;
BEGIN
    SELECT coalesce(u.val, c.val, b.val)
    INTO ret
    FROM jsonb_path_query(listing, ('$.user.' || path)::JSONPATH) WITH ORDINALITY u(val, idx)
             FULL JOIN jsonb_path_query(listing, ('$.custom.' || path)::JSONPATH) WITH ORDINALITY c(val, idx)
                       USING (idx)
             FULL JOIN jsonb_path_query(listing, ('$.base.' || path)::JSONPATH) WITH ORDINALITY b(val, idx)
                       USING (idx)
    LIMIT 1;

    RETURN ret;
END
$$;


CREATE OR REPLACE FUNCTION to_real(val JSONB) RETURNS REAL
    RETURNS NULL ON NULL INPUT
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN (val #>> '{}')::REAL;
END;
$$;


CREATE OR REPLACE FUNCTION to_real(val TEXT) RETURNS REAL
    RETURNS NULL ON NULL INPUT
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN to_real(nullif(regexp_replace(replace(val, ',', '.'), '[^0-9.]', '', 'g'), '')::JSONB);
END;
$$;


INSERT INTO watch_lists (url)
VALUES ('https://www.willhaben.at/iad/immobilien/eigentumswohnung/steiermark?a');
INSERT INTO watch_lists (url)
VALUES ('https://www.willhaben.at/iad/immobilien/haus-kaufen/steiermark?a');



INSERT INTO functions (function, name)
VALUES ('(to_real(val) > 50) * -1', 'Lärm');
INSERT INTO functions (function, name)
VALUES (e'  (jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT = any(\'{"Loft/Studio","Garconniere","Rohdachboden","Maisonette"}\'))::INT
+ (lower(jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT) like \'%wohnung%\')::INT
', 'ist Wohnung');
INSERT INTO functions (function, name)
VALUES ('(to_real(val) > 700000) * -1', 'Preis > 700k');
INSERT INTO functions (function, name)
VALUES ('(length(val::TEXT) > 0)::INT * -1', 'Nicht leer');
INSERT INTO functions (function, name)
VALUES ('to_real(val) / 200000', '/ 200 000');
INSERT INTO functions (function, name)
VALUES (e'  (jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT = any(\'{"Villa","Bungalow","Rohbau"}\'))::INT
+ (lower(jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT) like \'%haus%\')::INT', 'ist Haus');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT sum((lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')::INT)
        FROM unnest(\'{"graz", "graz-umgebung"}\'::TEXT[]) ws(w)
    )::INTEGER ', 'Bezirke Haus');
INSERT INTO functions (function, name)
VALUES ('jsonb_build_object(''href'',  row->''base''->''attributeMap''->''SEO_URL''->>0, ''heading'', coalesce(row->''base''->''description''->>0, row->''base''->''attributeMap''->''SEO_URL''->>0) )',
        'PSQL Title');
INSERT INTO functions (function, name)
VALUES ('''-''::TEXT', 'PSQL Empty');
INSERT INTO functions (function, name)
VALUES ('to_real(val) * 2', 'SQL Prio 2');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (SELECT
FROM unnest(\'{"fernblick", "aussicht", "weitblick", "fußbodenheizung", "fussbodenheizung", "garage", "carport", "balkon", "terasse", "terrasse"}\'::TEXT[]) ws(w)
WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\'))::INTEGER', 'PSQL Gute Wörter');
INSERT INTO functions (function, name)
VALUES ('(to_real(val) - 150) / 150', 'Wohnfläche Haus');
INSERT INTO functions (function, name)
VALUES ('''-''::TEXT', 'Attr:Leer');
INSERT INTO functions (function, name)
VALUES ('val', 'Wohnung Aussenanlagen');
INSERT INTO functions (function, name)
VALUES ('(8000 - to_real(val)) / 8000', 'Distanz Normalisiert');
INSERT INTO functions (function, name)
VALUES ('to_real(val) * 2', 'Prio 2');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT FROM unnest(\'{"garage", "carport", "parkplatz"}\'::TEXT[]) ws(w)
        WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')
    )::INTEGER * -1', 'Fehlende Wörter');
INSERT INTO functions (function, name)
VALUES ('to_real(val) * 10', 'Prio 10');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT sum((lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')::INT)
        FROM unnest(\'{"green tower", "esplanade", "am puls der zeit", "urbangreengeidorf", "falling water", "jakomini verde", "fatestone"}\'::TEXT[]) ws(w)
    )::INTEGER * -1', 'No Go');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT sum((lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')::INT)
        FROM unnest(\'{"graz"}\'::TEXT[]) ws(w)
    )::INTEGER ', 'Bezirke Wohnung');
INSERT INTO functions (function, name)
VALUES ('1', '1');
INSERT INTO functions (function, name)
VALUES ('tanh(to_real(val))', 'tanh');
INSERT INTO functions (function, name)
VALUES ('pow(0.5772156649, -(to_real(val) * to_real(val)) / 0.32) / sqrt(2 * PI() * 0.16)',
        'Normalverteilung (sig=0.4)');
INSERT INTO functions (function, name)
VALUES ('(to_real(val) - 100) / 100', 'Wohnfläche Wohnung');
INSERT INTO functions (function, name)
VALUES ('(400000 - to_real(val)) / 400000', 'Preis normalisiert');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
    SELECT FROM unnest(\'{"wohnrecht", "bauherrenmodell", "anlageobjekt", "anlegerwohnung", "anleger", "vermietet", "mieteinnahmen", " bms ", "beteiligungsprojekt", "rohdachboden", "ordinationsräumlichkeiten"}\'::TEXT[]) ws(w)
    WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')
)::INTEGER * -1', 'Schlechte Wörter');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
    SELECT FROM unnest(\'{"fernblick", "aussicht", "weitblick", "fußbodenheizung", "fussbodenheizung", "garage", "carport", "balkon", "terasse", "terrasse"}\'::TEXT[]) ws(w)
    WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')
)::INTEGER', 'Gute Wörter');
INSERT INTO functions (function, name)
VALUES ('''47.067393,15.442110;'' || nullif(val::TEXT, '''')', 'Add Graz Jakominiplatz');
INSERT INTO functions (function, name)
VALUES (e'CASE WHEN nullif(\'\', \'\') IS NOT NULL THEN st_distance((\'SRID=4326;POINT(\' || regexp_replace(split_part(val::TEXT, \';\', 1), \'[,"]\', \' \', \'g\') || \')\')::geography,
                    (\'SRID=4326;POINT(\' || regexp_replace(split_part(val::TEXT, \';\', 2), \'[,"]\', \' \', \'g\') || \')\')::geography
        ) END', 'Distance between 2 Points');
INSERT INTO functions (function, name)
VALUES (e'jsonb_build_object(\'href\', row->\'base\'->\'attributeMap\'->>\'seoUrl\',
                           \'heading\', coalesce(row->\'base\'->>\'description\',
                                               row->\'base\'->\'attributeMap\'->>\'seoUrl\'
                                      )
        )', 'Attr:Link');
INSERT INTO functions (function, name)
VALUES (e'to_real(substring( row->\'base\'->\'attributeMap\'->>\'price\' FROM \'[0-9,.]+\')) /
        greatest(
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'plotArea\' FROM \'[0-9,.]+\'), \'1\')),
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'estateSizeLivingArea\' FROM \'[0-9,.]+\'), \'1\'))
        )', 'Zimmer < 3.5');
INSERT INTO functions (function, name)
VALUES (e'to_real(substring( row->\'base\'->\'attributeMap\'->>\'price\' FROM \'[0-9,.]+\')) /
        greatest(
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'plotArea\' FROM \'[0-9,.]+\'), \'1\')),
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'estateSizeLivingArea\' FROM \'[0-9,.]+\'), \'1\'))
        )', 'Preis/m2');
INSERT INTO functions (function, name)
VALUES (e'to_real(substring( row->\'base\'->\'attributeMap\'->\'PRICE\'->>0 FROM \'[0-9,]+\')) /
       greatest(
               to_real(coalesce(row->\'base\'->\'attributeMap\'->\'PLOT/AREA\'->>0, \'1\')),
                to_real(coalesce(row->\'base\'->\'attributeMap\'->\'ESTATE_SIZE/LIVING_AREA\'->>0, \'1\'))
       )', 'PSQL Preis/m2');
