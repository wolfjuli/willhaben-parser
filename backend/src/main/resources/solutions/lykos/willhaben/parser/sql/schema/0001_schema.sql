CREATE TABLE schema_version
(
    patch_level      INT NOT NULL
        PRIMARY KEY,
    patch_file       TEXT,
    created_datetime TIMESTAMP WITH TIME ZONE DEFAULT current_timestamp
);


CREATE TABLE watch_lists
(
    id  INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    url TEXT NOT NULL
        UNIQUE
);


CREATE TABLE listings
(
    id               INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    created_datetime TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    last_seen        TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    willhaben_id     INTEGER                                NOT NULL,
    hash             TEXT                                   NOT NULL
        UNIQUE,
    duplicate_hash   TEXT                                   NOT NULL,
    raw              jsonb                                  NOT NULL
);


CREATE INDEX listings_duplicate_hash_idx
    ON listings (duplicate_hash);

CREATE INDEX listings_last_seen_idx
    ON listings (last_seen);

CREATE INDEX listings_willhaben_id_idx
    ON listings (willhaben_id);

CREATE TABLE listing_user_attributes
(
    listing_id   INTEGER NOT NULL REFERENCES listings ON UPDATE CASCADE ON DELETE CASCADE,
    attribute_id INTEGER NOT NULL REFERENCES attributes (id) ON DELETE CASCADE ON UPDATE CASCADE,
    values       jsonb,
    PRIMARY KEY (listing_id, attribute_id)
);


CREATE TABLE functions
(
    id       INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    function TEXT NOT NULL,
    name     TEXT
);


CREATE TABLE scripts
(
    id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_id INT NOT NULL REFERENCES attributes (id) ON DELETE CASCADE ON UPDATE CASCADE,
    name         TEXT
);


CREATE TABLE script_functions
(
    script_id   INT NOT NULL
        REFERENCES scripts
            ON UPDATE CASCADE ON DELETE CASCADE,
    function_id INT NOT NULL
        REFERENCES functions
            ON UPDATE CASCADE ON DELETE CASCADE,
    ord         INT NOT NULL,
    PRIMARY KEY (script_id, function_id, ord)
);


CREATE TABLE listing_points
(
    listing_id   INTEGER NOT NULL
        REFERENCES listings
            ON UPDATE CASCADE ON DELETE CASCADE,
    attribute_id INT     NOT NULL,
    script_id    INT     NOT NULL
        REFERENCES scripts
            ON UPDATE CASCADE ON DELETE CASCADE,
    points       DOUBLE PRECISION,
    PRIMARY KEY (listing_id, attribute_id, script_id)
);


CREATE INDEX listing_points_points_idx
    ON listing_points (points);

CREATE TABLE attributes
(
    id        SERIAL PRIMARY KEY,
    attribute TEXT NOT NULL UNIQUE,
    label     TEXT,
    data_type data_type
);


CREATE TABLE custom_attributes
(
    id          INTEGER   NOT NULL PRIMARY KEY REFERENCES attributes ON UPDATE CASCADE ON DELETE CASCADE,
    function_id INT       NOT NULL REFERENCES functions ON UPDATE CASCADE ON DELETE CASCADE,
    data_type   data_type NOT NULL
);


CREATE MATERIALIZED VIEW willhaben.duplicate_listings AS
SELECT c.id            AS listing_id,
       array_agg(s.id) AS sibblings
FROM listings c
JOIN listings s
    ON c.duplicate_hash = s.duplicate_hash
GROUP BY c.id;


CREATE VIEW folded_scripts(script_id, attribute_id, script) AS
SELECT script_id,
       attribute_id,
       ((((('(v, r) => {'::TEXT || funs) || ' return '::TEXT) || folded) || 'v'::TEXT) ||
        repeat(', r)'::TEXT, count::INTEGER)) || '; }'::TEXT AS script
FROM (SELECT s.id                                                                          AS script_id,
             s.attribute_id,
             count(*)                                                                      AS count,
             string_agg(DISTINCT ((('const fun'::TEXT || f.id) || ' = '::TEXT) || f.function) || '; '::TEXT,
                        ''::TEXT)                                                          AS funs,
             string_agg(('fun'::TEXT || f.id) || '('::TEXT, ''::TEXT ORDER BY sf.ord DESC) AS folded
      FROM scripts s
      JOIN script_functions sf
          ON s.id = sf.script_id
      JOIN functions f
          ON sf.function_id = f.id
      GROUP BY s.id, s.attribute_id) x;


CREATE VIEW fe_configuration(image_base_url, listings_base_url) AS
SELECT 'https://cache.willhaben.at/mmo'::TEXT AS image_base_url,
       'https://www.willhaben.at/iad/'::TEXT  AS listings_base_url;

DROP FUNCTION IF EXISTS update_normalized_listings;
DROP TABLE IF EXISTS normalized_listings;
CREATE TABLE normalized_listings
(
    listing_id   INT PRIMARY KEY REFERENCES listings (id) ON DELETE CASCADE ON UPDATE CASCADE,
    willhaben_id INT,
    listing      jsonb NOT NULL,
    md5          TEXT  NOT NULL
);

/** Materialized views dont allow function calls anymore (for a security reason), thus we have to do it by ourself **/
CREATE OR REPLACE FUNCTION update_normalized_listings(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                      listing_ids INTEGER[] DEFAULT NULL::INTEGER[])
    RETURNS TABLE
            (
                like normalized_listings
            )
    VOLATILE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY WITH RECURSIVE
        ls AS (
            SELECT id,
                   created_datetime,
                   last_seen,
                   willhaben_id,
                   hash,
                   duplicate_hash,
                   raw || jsonb_build_object('listingId', id) AS raw
            FROM listings
            WHERE (willhaben_ids IS NULL OR willhaben_id = ANY (willhaben_ids))
              AND (listing_ids IS NULL OR id = ANY (listing_ids))
            ),
        ca AS (SELECT l_1.id                                                                     AS listing_id,
                      jsonb_object_agg(a.attribute,
                                       unpack_run_function(f.function, 'null'::jsonb,
                                                           jsonb_build_object('base', l_1.raw))) AS raw
               FROM ls l_1
               CROSS JOIN custom_attributes ca_1
               JOIN attributes a
                   ON a.id = ca_1.id
               JOIN functions f
                   ON f.id = ca_1.function_id
               GROUP BY l_1.id),
        attr_raw AS (SELECT lua.listing_id,
                            a.id AS attribute_id,
                            s.idx,
                            s.part,
                            lua.values
                     FROM listing_user_attributes lua
                     JOIN attributes a
                         ON a.id = lua.attribute_id
                     CROSS JOIN unnest(regexp_split_to_array(a.attribute, '\.')) WITH ORDINALITY s(part, idx)),
        direct_parents AS (SELECT r.listing_id, p.part AS parent, r.part, r.idx, r.values
                           FROM attr_raw r
                           LEFT JOIN attr_raw p
                               ON p.listing_id = r.listing_id
                               AND p.attribute_id = r.attribute_id
                               AND p.idx = r.idx - 1),
        r_ua AS (SELECT r.listing_id, r.parent, r.idx, jsonb_object_agg(r.part, r.values) AS obj
                 FROM direct_parents r
                 JOIN (SELECT x.listing_id, x.parent, max(x.idx) AS idx FROM direct_parents x GROUP BY 1, 2) x
                     USING (listing_id, parent, idx)
                 GROUP BY r.listing_id, r.parent, r.idx


                 UNION ALL

                 SELECT r.listing_id, r.parent, r.idx, jsonb_build_object(r.part, r_ua.obj) AS obj
                 FROM r_ua
                 JOIN direct_parents r
                     ON r.listing_id = r_ua.listing_id
                     AND r.part = r_ua.parent
                     AND r.idx = r_ua.idx - 1),
        ua AS (SELECT DISTINCT listing_id, obj AS raw
               FROM r_ua
               WHERE idx = 1)
        INSERT INTO normalized_listings (listing_id, willhaben_id, listing, md5)
            SELECT l.id                                                                           AS listing_id,
                   l.willhaben_id,
                   jsonb_build_object('base', l.raw, 'custom', ca.raw, 'user', ua.raw)            AS listing,
                   md5(jsonb_build_object('base', l.raw, 'custom', ca.raw, 'user', ua.raw)::TEXT) AS md5
            FROM ls l
            LEFT JOIN ca
                ON l.id = ca.listing_id
            LEFT JOIN ua
                ON l.id = ua.listing_id
            ON CONFLICT (listing_id) DO UPDATE SET willhaben_id = excluded.willhaben_id, listing = excluded.listing, md5 = excluded.md5
            RETURNING listing_id, willhaben_id, listing, md5;

END;
$$;



CREATE FUNCTION get_id() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
DECLARE
    new_id INT;
BEGIN
    WITH existing AS (SELECT id
                      FROM attributes
                      WHERE attribute = new.attribute),
         ins AS (
             INSERT INTO attribute_mapping SELECT
                                           WHERE NOT exists (SELECT FROM existing)
                 RETURNING id)
    SELECT id
    INTO new_id
    FROM (SELECT id FROM existing UNION ALL SELECT id FROM ins) x;

    new.id := new_id;
    RETURN coalesce(new, old);
END;
$$;

CREATE OR REPLACE FUNCTION update_listing_points(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 attribute_ids INT[] DEFAULT NULL::INT[],
                                                 listing_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 script_ids INT[] DEFAULT NULL::INT[])

    RETURNS TABLE
            (
                like listing_points
            )
    VOLATILE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        INSERT INTO listing_points (listing_id, attribute_id, script_id, points)
            SELECT listing_id,
                   attribute_id,
                   s.id,
                   nullif(run_script(s.id, listing_id), 'null')::DOUBLE PRECISION
            FROM normalized_listings l
            CROSS JOIN scripts s
            WHERE (willhaben_ids IS NULL OR
                   listing_id IN (SELECT id FROM listings WHERE willhaben_id = ANY (willhaben_ids)))
              AND (listing_ids IS NULL OR listing_id = ANY (listing_ids))
              AND (attribute_ids IS NULL OR attribute_id = ANY (attribute_ids))
              AND (script_ids IS NULL OR s.id = ANY (script_ids))
            ON CONFLICT (listing_id, attribute_id, script_id) DO UPDATE SET points = excluded.points
            RETURNING listing_id, attribute_id, script_id, points;
END;
$$;


CREATE FUNCTION changed_listing_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION change_listing_custom_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_normalize_listings(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_normalized_listings() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);

END;
$$;


CREATE FUNCTION changed_user_defined_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_script_functions() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(script_ids := ARRAY [coalesce(new.script_id, old.script_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_custom_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(attribute_ids := ARRAY [coalesce(new.id, old.id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_functions() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(function_ids := ARRAY [coalesce(new.id, old.id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION toggle_triggers(action TEXT, namespace TEXT DEFAULT 'willhaben'::TEXT) RETURNS VOID
    LANGUAGE plpgsql
AS
$$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT c.relname, t.tgname
             FROM pg_namespace n
             JOIN pg_class c
                 ON c.relnamespace = n.oid
             JOIN pg_trigger t
                 ON t.tgrelid = c.oid
             WHERE n.nspname = namespace
               AND t.tgname LIKE 'trg_changed%'
        LOOP
            EXECUTE format('alter table %I.%I %s trigger %s', namespace, r.relname, action, r.tgname);
        END LOOP;
END;
$$;

CREATE OR REPLACE FUNCTION run_script_steps(_script_id INT, _listing_id INTEGER)
    RETURNS TABLE
            (
                script_id   INT,
                listing_id  INTEGER,
                function_id INTEGER,
                value       jsonb,
                ord         INT
            )
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY WITH RECURSIVE
                     sfs AS (SELECT s.id AS script_id, -s.attribute_id AS function_id, 0 AS ord
                             FROM scripts s

                             UNION ALL

                             SELECT sf.script_id, sf.function_id, sf.ord
                             FROM script_functions sf),
                     fs AS (SELECT -a.id                                                AS function_id,
                                   'listing_path_query(row, ''' || a.attribute || ''')' AS function,
                                   'Get value ' || a.attribute                          AS name,
                                   NULL                                                 AS value
                            FROM attributes a

                            UNION ALL

                            SELECT id, function, name, NULL
                            FROM functions),
                     intermediate AS (SELECT sfs.script_id,
                                             unpack_run_function(fs.function, 'null'::jsonb, l.listing) AS value,
                                             fs.function_id,
                                             l.listing,
                                             sfs.ord
                                      FROM normalized_listings l
                                      JOIN sfs
                                          ON l.listing_id = _listing_id
                                          AND sfs.script_id = _script_id
                                          AND sfs.ord = 0
                                      JOIN fs
                                          ON sfs.function_id = fs.function_id

                                      UNION ALL

                                      SELECT sfs.script_id,
                                             unpack_run_function(fs.function, i.value, listing) AS value,
                                             fs.function_id,
                                             i.listing,
                                             sfs.ord
                                      FROM intermediate i
                                      JOIN sfs
                                          ON sfs.script_id = i.script_id
                                          AND sfs.ord = i.ord + 1
                                      JOIN fs
                                          ON sfs.function_id = fs.function_id)
                 SELECT _script_id, _listing_id, i.function_id, i.value, i.ord::INT
                 FROM intermediate i;
END;
$$;

CREATE OR REPLACE FUNCTION run_script(_script_id INT, _listing_id INTEGER) RETURNS jsonb
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
DECLARE
    res jsonb;
BEGIN

    WITH maxs AS (SELECT max(ord) AS ord, sf.script_id
                  FROM script_functions sf
                  WHERE sf.script_id = _script_id
                  GROUP BY sf.script_id)
    SELECT rs.value
    INTO res
    FROM run_script_steps(_script_id, _listing_id) rs
    JOIN maxs m
        ON rs.script_id = m.script_id
        AND rs.ord = m.ord;

    RETURN res;

END;
$$;

CREATE OR REPLACE FUNCTION run_function(_function TEXT, attribute jsonb, listing jsonb)
    RETURNS jsonb
    LANGUAGE plpgsql
    IMMUTABLE
AS
$$
DECLARE
    res     jsonb;
    sql     TEXT ;
    errtext TEXT;
    details TEXT;
BEGIN
    sql := 'SELECT to_jsonb(' || _function || ') from (values(''' || replace(attribute::TEXT,  '''', '''''') ||
           '''::JSONB, ''' ||
           replace((jsonb_build_object('a', listing::TEXT) ->> 'a')::TEXT, '''', '''''') ||
           '''::JSONB)) r(val, row)';

    EXECUTE sql INTO res;
    RETURN jsonb_build_object('value', res);
EXCEPTION
    WHEN OTHERS THEN
        GET STACKED DIAGNOSTICS errtext := MESSAGE_TEXT;
        GET STACKED DIAGNOSTICS details := PG_EXCEPTION_DETAIL;

        RETURN jsonb_build_object('error', jsonb_build_object(
                'message', errtext,
                'sql', sql,
                'details', details,
                'listing', listing,
                'value', attribute,
                'function', _function
                                           ));
END;
$$;

CREATE OR REPLACE FUNCTION run_function(function_id INT, attribute TEXT, listing jsonb) RETURNS jsonb
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN run_function((SELECT function FROM functions WHERE id = function_id), attribute, listing);
END;
$$;

CREATE OR REPLACE FUNCTION unpack_run_function(_function TEXT, attribute jsonb, listing jsonb) RETURNS jsonb
    LANGUAGE plpgsql
AS
$$
DECLARE
    ret jsonb := run_function(_function, attribute, listing);
BEGIN
    CASE
        WHEN ret ->> 'error' IS NOT NULL
            THEN RAISE EXCEPTION 'Error: %, FnName: %, ListingID: %, WillhabenID: %', ret ->> 'error', (SELECT string_agg(name, ', ') FROM functions WHERE function = _function), listing -> 'base' ->> 'listingId', listing -> 'base' ->> 'id';
        ELSE RETURN ret -> 'value';
        END CASE;
END;
$$;

CREATE OR REPLACE FUNCTION unpack_run_function(function_id INT, attribute TEXT, listing jsonb) RETURNS jsonb
    LANGUAGE plpgsql
AS
$$
DECLARE
    ret jsonb := run_function(function_id, attribute, listing);
BEGIN
    CASE
        WHEN ret ->> 'error' IS NOT NULL
            THEN RAISE EXCEPTION 'Error: %, FnName: %, ListingID: %, WillhabenID: %', ret ->> 'error', (SELECT string_agg(name, ', ') FROM functions WHERE id = function_id), listing -> 'base' ->> 'listingId', listing -> 'base' ->> 'id';
        ELSE RETURN ret -> 'value';
        END CASE;
END;
$$;

CREATE OR REPLACE FUNCTION update_listing_points(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 attribute_ids INT[] DEFAULT NULL::INT[],
                                                 listing_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 script_ids INT[] DEFAULT NULL::INT[])
    RETURNS TABLE
            (
                "like" listing_points
            )
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        INSERT INTO listing_points (listing_id, attribute_id, script_id, points)
            SELECT listing_id,
                   attribute_id,
                   s.id,
                   run_script(s.id, listing_id)::TEXT::DOUBLE PRECISION
            FROM normalized_listings l
            CROSS JOIN scripts s
            WHERE (willhaben_ids IS NULL OR
                   listing_id IN (SELECT id FROM listings WHERE willhaben_id = ANY (willhaben_ids)))
              AND (listing_ids IS NULL OR listing_id = ANY (listing_ids))
              AND (attribute_ids IS NULL OR attribute_id = ANY (attribute_ids))
              AND (script_ids IS NULL OR s.id = ANY (script_ids))
            ON CONFLICT (listing_id, attribute_id, script_id) DO UPDATE SET points = excluded.points
            RETURNING listing_id, attribute_id, script_id, points;
END;
$$;


CREATE FUNCTION listing_path_query(listing jsonb, path TEXT) RETURNS jsonb
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
DECLARE
    ret jsonb;
BEGIN
    SELECT coalesce(u.val, c.val, b.val)
    INTO ret
    FROM jsonb_path_query(listing, ('$.user.' || path)::jsonpath) WITH ORDINALITY u(val, idx)
    FULL JOIN jsonb_path_query(listing, ('$.custom.' || path)::jsonpath) WITH ORDINALITY c(val, idx)
        USING (idx)
    FULL JOIN jsonb_path_query(listing, ('$.base.' || path)::jsonpath) WITH ORDINALITY b(val, idx)
        USING (idx)
    LIMIT 1;

    RETURN ret;
END
$$;


CREATE OR REPLACE FUNCTION to_real(val jsonb) RETURNS REAL
    RETURNS NULL ON NULL INPUT
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN nullif(nullif(substr(val #>> '{}', 26), 'null'), '')::REAL;
END;
$$;


CREATE OR REPLACE FUNCTION to_real(val TEXT) RETURNS REAL
    RETURNS NULL ON NULL INPUT
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN to_real(nullif(regexp_replace(replace(val, ',', '.'), '[^0-9.]', '', 'g'), '')::jsonb);
END;
$$;

INSERT INTO functions (function, name)
VALUES ('(to_real(val) > 50)::INT * -1', 'Lärm');
INSERT INTO functions (function, name)
VALUES (e'  (jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT = any(\'{"Loft/Studio","Garconniere","Rohdachboden","Maisonette"}\'))::INT
+ (lower(jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT) like \'%wohnung%\')::INT
', 'ist Wohnung');
INSERT INTO functions (function, name)
VALUES ('(to_real(val) > 700000)::INT * -1', 'Preis > 700k');
INSERT INTO functions (function, name)
VALUES ('(length(val::TEXT) > 0)::INT * -1', 'Nicht leer');
INSERT INTO functions (function, name)
VALUES ('to_real(val) / 200000', '/ 200 000');
INSERT INTO functions (function, name)
VALUES (e'  (jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT = any(\'{"Villa","Bungalow","Rohbau"}\'))::INT
+ (lower(jsonb_path_query(row, \'$.base.attributeMap.propertyType\')::TEXT) like \'%haus%\')::INT', 'ist Haus');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT sum((lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')::INT)
        FROM unnest(\'{"graz", "graz-umgebung"}\'::TEXT[]) ws(w)
    )::INTEGER) ', 'Bezirke Haus');
INSERT INTO functions (function, name)
VALUES ('jsonb_build_object(''href'',  row->''base''->''attributeMap''->''SEO_URL''->>0, ''heading'', coalesce(row->''base''->''description''->>0, row->''base''->''attributeMap''->''SEO_URL''->>0) )',
        'PSQL Title');
INSERT INTO functions (function, name)
VALUES ('''-''::TEXT', 'PSQL Empty');
INSERT INTO functions (function, name)
VALUES ('to_real(val) * 2', 'SQL Prio 2');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (SELECT
FROM unnest(\'{"fernblick", "aussicht", "weitblick", "fußbodenheizung", "fussbodenheizung", "garage", "carport", "balkon", "terasse", "terrasse"}\'::TEXT[]) ws(w)
WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\'))::INTEGER', 'PSQL Gute Wörter');
INSERT INTO functions (function, name)
VALUES ('(to_real(val) - 150) / 150', 'Wohnfläche Haus');
INSERT INTO functions (function, name)
VALUES ('''-''::TEXT', 'Attr:Leer');
INSERT INTO functions (function, name)
VALUES ('val', 'Wohnung Aussenanlagen');
INSERT INTO functions (function, name)
VALUES ('(8000 - to_real(val)) / 8000', 'Distanz Normalisiert');
INSERT INTO functions (function, name)
VALUES ('to_real(val) * 2', 'Prio 2');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT FROM unnest(\'{"garage", "carport", "parkplatz"}\'::TEXT[]) ws(w)
        WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')
    )::INTEGER * -1', 'Fehlende Wörter');
INSERT INTO functions (function, name)
VALUES ('to_real(val) * 10', 'Prio 10');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT sum((lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')::INT)
        FROM unnest(\'{"green tower", "esplanade", "am puls der zeit", "urbangreengeidorf", "falling water", "jakomini verde", "fatestone"}\'::TEXT[]) ws(w)
    )::INTEGER * -1)', 'No Go');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
        SELECT sum((lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')::INT)
        FROM unnest(\'{"graz"}\'::TEXT[]) ws(w)
    )::INTEGER )', 'Bezirke Wohnung');
INSERT INTO functions (function, name)
VALUES ('1', '1');
INSERT INTO functions (function, name)
VALUES ('tanh(to_real(val))', 'tanh');
INSERT INTO functions (function, name)
VALUES ('pow(0.5772156649, -(to_real(val) * to_real(val)) / 0.32) / sqrt(2 * PI() * 0.16)',
        'Normalverteilung (sig=0.4)');
INSERT INTO functions (function, name)
VALUES ('(to_real(val) - 100) / 100', 'Wohnfläche Wohnung');
INSERT INTO functions (function, name)
VALUES ('(400000 - to_real(val)) / 400000', 'Preis normalisiert');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
    SELECT FROM unnest(\'{"wohnrecht", "bauherrenmodell", "anlageobjekt", "anlegerwohnung", "anleger", "vermietet", "mieteinnahmen", " bms ", "beteiligungsprojekt", "rohdachboden", "ordinationsräumlichkeiten"}\'::TEXT[]) ws(w)
    WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')
)::INTEGER * -1', 'Schlechte Wörter');
INSERT INTO functions (function, name)
VALUES (e'(SELECT exists (
    SELECT FROM unnest(\'{"fernblick", "aussicht", "weitblick", "fußbodenheizung", "fussbodenheizung", "garage", "carport", "balkon", "terasse", "terrasse"}\'::TEXT[]) ws(w)
    WHERE lower(val::TEXT) LIKE \'%\' || ws.w || \'%\')
)::INTEGER', 'Gute Wörter');
INSERT INTO functions (function, name)
VALUES ('''47.067393,15.442110;'' || nullif(val::TEXT, '''')', 'Add Graz Jakominiplatz');
INSERT INTO functions (function, name)
VALUES (e'CASE WHEN nullif(\'\', \'\') IS NOT NULL THEN st_distance((\'SRID=4326;POINT(\' || regexp_replace(split_part(val::TEXT, \';\', 1), \'[,"]\', \' \', \'g\') || \')\')::geography,
                    (\'SRID=4326;POINT(\' || regexp_replace(split_part(val::TEXT, \';\', 2), \'[,"]\', \' \', \'g\') || \')\')::geography
        ) END', 'Distance between 2 Points');
INSERT INTO functions (function, name)
VALUES (e'jsonb_build_object(\'href\', row->\'base\'->\'attributeMap\'->>\'seoUrl\',
                           \'heading\', coalesce(row->\'base\'->>\'description\',
                                               row->\'base\'->\'attributeMap\'->>\'seoUrl\'
                                      )
        )', 'Attr:Link');
INSERT INTO functions (function, name)
VALUES (e'to_real(substring( row->\'base\'->\'attributeMap\'->>\'price\' FROM \'[0-9,.]+\')) /
        greatest(
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'plotArea\' FROM \'[0-9,.]+\'), \'1\')),
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'estateSizeLivingArea\' FROM \'[0-9,.]+\'), \'1\'))
        )', 'Zimmer < 3.5');
INSERT INTO functions (function, name)
VALUES (e'to_real(substring( row->\'base\'->\'attributeMap\'->>\'price\' FROM \'[0-9,.]+\')) /
        greatest(
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'plotArea\' FROM \'[0-9,.]+\'), \'1\')),
                to_real(coalesce(substring( row->\'base\'->\'attributeMap\'->>\'estateSizeLivingArea\' FROM \'[0-9,.]+\'), \'1\'))
        )', 'Preis/m2');
INSERT INTO functions (function, name)
VALUES (e'to_real(substring( row->\'base\'->\'attributeMap\'->\'PRICE\'->>0 FROM \'[0-9,]+\')) /
       greatest(
               to_real(coalesce(row->\'base\'->\'attributeMap\'->\'PLOT/AREA\'->>0, \'1\')),
                to_real(coalesce(row->\'base\'->\'attributeMap\'->\'ESTATE_SIZE/LIVING_AREA\'->>0, \'1\'))
       )', 'PSQL Preis/m2');


WITH vs(attribute, name) AS (VALUES ('attributeMap.heading', 'No Go Title'),
                                    ('attributeMap.heading', 'Schlechte Wörter Titel'),
                                    ('attributeMap.heading', 'Gute Wörter Titel'),
                                    ('attributeMap.coordinates', 'Location'),
                                    ('attributeMap.district', 'Gute Bezirke Wohnung'),
                                    ('attributeMap.district', 'Gute Bezirke Haus'),
                                    ('attributeMap.propertyType', 'Ist Haus'),
                                    ('attributeMap.estateSizeLivingArea', 'Wohnfläche Wohnung'),
                                    ('attributeMap.estateSizeLivingArea', 'Wohnfläche Haus'),
                                    ('attributeMap.rooms', 'Zimmer < 3,5'),
                                    ('attributeMap.price', 'Preis > 700k'),
                                    ('attributeMap.price', 'Preis'),
                                    ('attributeMap.description', 'PSQL Gute Wörter'),
                                    ('attributeMap.description', 'No Go'),
                                    ('attributeMap.description', 'Fehlende Wörter'),
                                    ('attributeMap.description', 'Schlechte Wörter desc'),
                                    ('attributeMap.description', 'Gute Wörter desc'),
                                    ('attributeMap.projectInfoTitle', 'Ist Projekthauptseite'))
INSERT
INTO scripts(attribute_id, name)
SELECT a.id, vs.name
FROM vs
JOIN attributes a
    ON a.attribute = vs.attribute;



WITH vs(script, function, ord) AS (VALUES ('Fehlende Wörter', 'Fehlende Wörter', 1),
                                          ('Fehlende Wörter', 'Prio 10', 2),
                                          ('Gute Bezirke Haus', 'Bezirke Haus', 1),
                                          ('Gute Bezirke Haus', 'Prio 10', 2),
                                          ('Gute Bezirke Haus', 'ist Haus', 3),
                                          ('Gute Bezirke Wohnung', 'Bezirke Wohnung', 1),
                                          ('Gute Bezirke Wohnung', 'Prio 10', 2),
                                          ('Gute Bezirke Wohnung', 'ist Wohnung', 3),
                                          ('Gute Wörter desc', 'Gute Wörter', 1),
                                          ('Gute Wörter desc', 'Prio 2', 2),
                                          ('Gute Wörter Titel', 'Gute Wörter', 1),
                                          ('Gute Wörter Titel', 'Prio 2', 2),
                                          ('Ist Haus', '1', 4),
                                          ('Ist Haus', 'ist Haus', 5),
                                          ('Ist Haus', 'Prio 10', 6),
                                          ('Ist Projekthauptseite', 'Nicht leer', 1),
                                          ('Ist Projekthauptseite', 'Prio 10', 2),
                                          ('Ist Projekthauptseite', 'Prio 2', 3),
                                          ('Ist Projekthauptseite', 'Prio 10', 4),
                                          ('Lärm', 'Lärm', 1),
                                          ('Lärm', 'Prio 2', 2),
                                          ('Lärm', 'Prio 10', 2),
                                          ('Location', 'Add Graz Jakominiplatz', 1),
                                          ('Location', 'Distance between 2 Points', 2),
                                          ('Location', 'Distanz Normalisiert', 3),
                                          ('Location', 'tanh', 4),
                                          ('Location', 'Prio 10', 5),
                                          ('No Go', 'No Go', 1),
                                          ('No Go', 'Prio 10', 2),
                                          ('No Go', 'Prio 2', 3),
                                          ('No Go Title', 'No Go', 1),
                                          ('No Go Title', 'Prio 10', 2),
                                          ('No Go Title', 'Prio 2', 3),
                                          ('Preis', 'Preis normalisiert', 1),
                                          ('Preis', 'Normalverteilung (sig=0.4)', 2),
                                          ('Preis', 'Prio 10', 3),
                                          ('Preis > 700k', 'Preis > 700k', 1),
                                          ('Preis > 700k', 'Prio 10', 2),
                                          ('PSQL Gute Wörter', 'PSQL Gute Wörter', 1),
                                          ('PSQL Gute Wörter', 'SQL Prio 2', 2),
                                          ('Schlechte Wörter desc', 'Schlechte Wörter', 1),
                                          ('Schlechte Wörter desc', 'Prio 10', 2),
                                          ('Schlechte Wörter Titel', 'Schlechte Wörter', 1),
                                          ('Schlechte Wörter Titel', 'Prio 10', 2),
                                          ('Wohnfläche Haus', 'Wohnfläche Haus', 1),
                                          ('Wohnfläche Haus', 'Normalverteilung (sig=0.4)', 2),
                                          ('Wohnfläche Haus', 'ist Haus', 3),
                                          ('Wohnfläche Haus', 'Prio 10', 4),
                                          ('Wohnfläche Wohnung', 'Wohnfläche Wohnung', 1),
                                          ('Wohnfläche Wohnung', 'Normalverteilung (sig=0.4)', 2),
                                          ('Wohnfläche Wohnung', 'ist Wohnung', 3),
                                          ('Wohnfläche Wohnung', 'Prio 10', 4),
                                          ('Zimmer < 3,5', 'Zimmer < 3.5', 1),
                                          ('Zimmer < 3,5', 'Prio 10', 4),
                                          ('Zimmer < 3,5', 'Prio 2', 5))
INSERT
INTO script_functions(script_id, function_id, ord)
SELECT s.id, f.id, sf.ord
FROM vs sf
JOIN scripts s
    ON sf.script = s.name
JOIN functions f
    ON sf.function = f.name
;

WITH vs(normalized, label, function_id, data_type) AS (VALUES ('seoUrl', 'Link', 12, 'LINK'),
                                                              ('pricePerArea', 'Preis/m2', 13, 'TEXT'),
                                                              ('notes', 'Notiz', 18, 'TEXT'),
                                                              ('db', 'dB', 18, 'TEXT')),
     attrs AS (
         INSERT
             INTO attributes (attribute, label, data_type)
                 SELECT normalized, label, data_type::data_type
                 FROM vs
                 RETURNING id, attribute)
INSERT
INTO custom_attributes(id, function_id, data_type)
SELECT a.id, vs.function_id, vs.data_type::data_type
FROM attrs a
JOIN vs
    ON a.attribute = vs.normalized;

