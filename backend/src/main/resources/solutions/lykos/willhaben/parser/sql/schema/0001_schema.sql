CREATE TABLE schema_version
(
    patch_level      SMALLINT NOT NULL
        PRIMARY KEY,
    patch_file       TEXT,
    created_datetime TIMESTAMP WITH TIME ZONE DEFAULT current_timestamp
);


CREATE TABLE watch_lists
(
    id  INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    url TEXT NOT NULL
        UNIQUE
);


CREATE TABLE listings
(
    id               INTEGER GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    created_datetime TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    last_seen        TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
    willhaben_id     INTEGER                                NOT NULL,
    hash             TEXT                                   NOT NULL
        UNIQUE,
    duplicate_hash   TEXT                                   NOT NULL,
    raw              JSONB                                  NOT NULL
);


CREATE INDEX listings_duplicate_hash_idx
    ON willhaben.listings (duplicate_hash);

CREATE INDEX listings_last_seen_idx
    ON willhaben.listings (last_seen);

CREATE INDEX listings_willhaben_id_idx
    ON willhaben.listings (willhaben_id);

CREATE TABLE listing_user_attributes
(
    listing_id   INTEGER NOT NULL
        CONSTRAINT user_defined_attributes_listing_id_fkey
            REFERENCES willhaben.listings
            ON UPDATE CASCADE ON DELETE CASCADE,
    attribute_id INTEGER NOT NULL,
    values       JSONB,
    CONSTRAINT user_defined_attributes_pkey
        PRIMARY KEY (listing_id, attribute_id)
);


CREATE TABLE functions
(
    id       SMALLINT GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    function TEXT NOT NULL,
    name     TEXT
);


CREATE TABLE scripts
(
    id           SMALLINT GENERATED BY DEFAULT AS IDENTITY
        PRIMARY KEY,
    attribute_id SMALLINT NOT NULL,
    name         TEXT
);


CREATE TABLE script_functions
(
    script_id   SMALLINT NOT NULL
        REFERENCES willhaben.scripts
            ON UPDATE CASCADE ON DELETE CASCADE,
    function_id SMALLINT NOT NULL
        REFERENCES willhaben.functions
            ON UPDATE CASCADE ON DELETE CASCADE,
    ord         SMALLINT NOT NULL,
    PRIMARY KEY (script_id, function_id, ord)
);


CREATE TABLE listing_points
(
    listing_id   INTEGER  NOT NULL
        REFERENCES willhaben.listings
            ON UPDATE CASCADE ON DELETE CASCADE,
    attribute_id SMALLINT NOT NULL,
    script_id    SMALLINT NOT NULL
        REFERENCES willhaben.scripts
            ON UPDATE CASCADE ON DELETE CASCADE,
    points       DOUBLE PRECISION,
    PRIMARY KEY (listing_id, attribute_id, script_id)
);


CREATE INDEX listing_points_points_idx
    ON willhaben.listing_points (points);

CREATE TABLE attributes
(
    id        SERIAL
        CONSTRAINT attributes_pkey1
            PRIMARY KEY,
    attribute TEXT NOT NULL
        CONSTRAINT attributes_attribute_key1
            UNIQUE,
    label     TEXT,
    data_type DATA_TYPE
);


CREATE TABLE custom_attributes
(
    id          INTEGER   NOT NULL
        CONSTRAINT custom_attributes_pkey1
            PRIMARY KEY
        CONSTRAINT custom_attributes_id_fkey1
            REFERENCES willhaben.attributes
            ON UPDATE CASCADE ON DELETE CASCADE,
    function_id SMALLINT  NOT NULL
        CONSTRAINT custom_attributes_function_id_fkey1
            REFERENCES willhaben.functions
            ON UPDATE CASCADE ON DELETE CASCADE,
    data_type   DATA_TYPE NOT NULL
);


CREATE MATERIALIZED VIEW willhaben.duplicate_listings AS
SELECT c.id            AS listing_id,
       array_agg(s.id) AS sibblings
FROM listings c
         JOIN listings s
              ON c.duplicate_hash = s.duplicate_hash
GROUP BY c.id;


CREATE VIEW folded_scripts(script_id, attribute_id, script) AS
SELECT script_id,
       attribute_id,
       ((((('(v, r) => {'::TEXT || funs) || ' return '::TEXT) || folded) || 'v'::TEXT) ||
        repeat(', r)'::TEXT, count::INTEGER)) || '; }'::TEXT AS script
FROM (SELECT s.id                                                                          AS script_id,
             s.attribute_id,
             count(*)                                                                      AS count,
             string_agg(DISTINCT ((('const fun'::TEXT || f.id) || ' = '::TEXT) || f.function) || '; '::TEXT,
                        ''::TEXT)                                                          AS funs,
             string_agg(('fun'::TEXT || f.id) || '('::TEXT, ''::TEXT ORDER BY sf.ord DESC) AS folded
      FROM scripts s
               JOIN script_functions sf
                    ON s.id = sf.script_id
               JOIN functions f
                    ON sf.function_id = f.id
      GROUP BY s.id, s.attribute_id) x;


CREATE VIEW fe_configuration(image_base_url, listings_base_url) AS
SELECT 'https://cache.willhaben.at/mmo'::TEXT AS image_base_url,
       'https://www.willhaben.at/iad/'::TEXT  AS listings_base_url;

DROP VIEW IF EXISTS normalized_listings;
CREATE VIEW normalized_listings(listing_id, willhaben_id, listing, md5) AS
WITH RECURSIVE
    ca AS (SELECT l_1.id                                                                                       AS listing_id,
                  jsonb_object_agg(a.attribute,
                                   run_function(f.function, a.attribute, jsonb_build_object('base', l_1.raw))) AS raw
           FROM listings l_1
                    CROSS JOIN custom_attributes ca_1
                    JOIN attributes a
                         ON a.id = ca_1.id
                    JOIN functions f
                         ON f.id = ca_1.function_id
           GROUP BY l_1.id),
    attr_raw AS (SELECT lua.listing_id,
                        a.id AS attribute_id,
                        s.idx,
                        s.part,
                        lua.values
                 FROM listing_user_attributes lua
                          JOIN attributes a
                               ON a.id = lua.attribute_id
                          CROSS JOIN unnest(regexp_split_to_array(a.attribute, '\.')) WITH ORDINALITY s(part, idx)),
    direct_parents AS (SELECT r.listing_id, p.part AS parent, r.part, r.idx, r.values
                       FROM attr_raw r
                                LEFT JOIN attr_raw p
                                          ON p.listing_id = r.listing_id
                                              AND p.attribute_id = r.attribute_id
                                              AND p.idx = r.idx - 1),
    r_ua AS (SELECT r.listing_id, r.parent, r.idx, jsonb_object_agg(r.part, r.values) AS obj
             FROM direct_parents r
                      JOIN (SELECT x.listing_id, x.parent, max(x.idx) AS idx FROM direct_parents x GROUP BY 1, 2) x
                           USING (listing_id, parent, idx)
             GROUP BY r.listing_id, r.parent, r.idx


             UNION ALL

             SELECT r.listing_id, r.parent, r.idx, jsonb_build_object(r.part, r_ua.obj) AS obj
             FROM r_ua
                      JOIN direct_parents r
                           ON r.listing_id = r_ua.listing_id
                               AND r.part = r_ua.parent
                               AND r.idx = r_ua.idx - 1),
    ua AS (SELECT DISTINCT listing_id, obj AS raw
           FROM r_ua
           WHERE idx = 1)
SELECT l.id                                                                           AS listing_id,
       l.willhaben_id,
       jsonb_build_object('base', l.raw, 'custom', ca.raw, 'user', ua.raw)            AS listing,
       md5(jsonb_build_object('base', l.raw, 'custom', ca.raw, 'user', ua.raw)::TEXT) AS md5
FROM listings l
         LEFT JOIN ca
                   ON l.id = ca.listing_id
         LEFT JOIN ua
                   ON l.id = ua.listing_id;


CREATE FUNCTION get_id() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
DECLARE
    new_id SMALLINT;
BEGIN
    WITH existing AS (SELECT id
                      FROM attributes
                      WHERE attribute = new.attribute),
         ins AS (
             INSERT INTO attribute_mapping SELECT
                                           WHERE NOT exists (SELECT FROM existing)
                 RETURNING id)
    SELECT id
    INTO new_id
    FROM (SELECT id FROM existing UNION ALL SELECT id FROM ins) x;

    new.id := new_id;
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION update_listing_points(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                      attribute_ids SMALLINT[] DEFAULT NULL::SMALLINT[],
                                      listing_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                      script_ids SMALLINT[] DEFAULT NULL::SMALLINT[])
    RETURNS TABLE
            (
                "like" LISTING_POINTS
            )
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY
        INSERT INTO listing_points (listing_id, attribute_id, script_id, points)
            SELECT listing_id,
                   attribute_id,
                   s.id,
                   run_script(s.id, listing_id)
            FROM normalized_listings l
                     CROSS JOIN scripts s
            WHERE (willhaben_ids IS NULL OR
                   listing_id IN (SELECT id FROM listings WHERE willhaben_id = ANY (willhaben_ids)))
              AND (listing_ids IS NULL OR listing_id = ANY (listing_ids))
              AND (attribute_ids IS NULL OR attribute_id = ANY (attribute_ids))
              AND (script_ids IS NULL OR s.id = ANY (script_ids))
            ON CONFLICT (listing_id, attribute_id, script_id) DO UPDATE SET points = excluded.points
            RETURNING listing_id, attribute_id, script_id, points;
END;
$$;


CREATE FUNCTION changed_listing_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION change_listing_custom_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_normalize_listings(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_normalized_listings() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_user_defined_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_normalize_listings(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    PERFORM update_listing_points(listing_ids := ARRAY [coalesce(new.listing_id, old.listing_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_script_functions() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_points(script_ids := ARRAY [coalesce(new.script_id, old.script_id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_custom_attributes() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(attribute_ids := ARRAY [coalesce(new.id, old.id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION changed_functions() RETURNS TRIGGER
    LANGUAGE plpgsql
AS
$$
BEGIN
    PERFORM update_listing_custom_attributes(function_ids := ARRAY [coalesce(new.id, old.id)]);
    RETURN coalesce(new, old);
END;
$$;


CREATE FUNCTION toggle_triggers(action TEXT, namespace TEXT DEFAULT 'willhaben'::TEXT) RETURNS VOID
    LANGUAGE plpgsql
AS
$$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT c.relname, t.tgname
             FROM pg_namespace n
                      JOIN pg_class c
                           ON c.relnamespace = n.oid
                      JOIN pg_trigger t
                           ON t.tgrelid = c.oid
             WHERE n.nspname = namespace
               AND t.tgname LIKE 'trg_changed%'
        LOOP
            EXECUTE format('alter table %I.%I %s trigger %s', namespace, r.relname, action, r.tgname);
        END LOOP;
END;
$$;


CREATE FUNCTION run_script(_script_id SMALLINT, _listing_id INTEGER) RETURNS JSONB
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
DECLARE
    res JSONB;
BEGIN

    WITH maxs AS (SELECT max(ord) AS ord, sf.script_id
                  FROM script_functions sf
                  WHERE sf.script_id = _script_id
                  GROUP BY sf.script_id)
    SELECT value
    INTO res
    FROM run_script_steps(_script_id, _listing_id) rs
             JOIN maxs m
                  ON rs.script_id = m.script_id
                      AND rs.ord = m.ord;

    RETURN res;

END;
$$;


CREATE OR REPLACE FUNCTION run_script_steps(_script_id SMALLINT, _listing_id INTEGER)
    RETURNS TABLE
            (
                SCRIPT_ID  SMALLINT,
                LISTING_ID INTEGER,
                VALUE      JSONB,
                ORD        SMALLINT
            )
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN QUERY WITH RECURSIVE
                     sfs AS (SELECT s.id AS script_id, -s.attribute_id AS function_id, 0 AS ord
                             FROM scripts s

                             UNION ALL

                             SELECT sf.script_id, sf.function_id, sf.ord
                             FROM script_functions sf),
                     fs AS (SELECT -a.id                                              AS function_id,
                                   'jsonb_path_query(row, ''' || a.attribute || ''')' AS function,
                                   'Get value ' || a.attribute                        AS name,
                                   NULL                                               AS value
                            FROM attributes a

                            UNION ALL

                            SELECT id, function, name, NULL
                            FROM functions),
                     intermediate AS (SELECT sfs.script_id,
                                             run_function(fs.function, '', l.listing) AS value,
                                             l.listing,
                                             sfs.ord
                                      FROM normalized_listings l
                                               JOIN sfs
                                                    ON l.listing_id = _listing_id
                                                        AND sfs.script_id = _script_id
                                                        AND sfs.ord = 0
                                               JOIN fs
                                                    USING (function_id)

                                      UNION ALL

                                      SELECT sfs.script_id,
                                             run_function(fs.function, i.value::TEXT, listing) AS value,
                                             i.listing,
                                             sfs.ord
                                      FROM intermediate i
                                               JOIN sfs
                                                    ON sfs.script_id = i.script_id
                                                        AND sfs.ord = i.ord + 1
                                               JOIN fs
                                                    USING (function_id))
                 SELECT sfs.script_id, _listing_id, value, ord
                 FROM intermediate i;
END;
$$;


CREATE FUNCTION run_function(_function TEXT, attribute TEXT, listing JSONB) RETURNS JSONB
    LANGUAGE plpgsql
AS
$$
DECLARE
    res JSONB;
    sql TEXT ;
BEGIN
    sql := 'SELECT to_jsonb(' || _function || ') from (values(''' || attribute || ''', ''' || listing::TEXT ||
           '''::JSONB)) r(val, row)';
    EXECUTE sql INTO res;
    RETURN res;
END;
$$;


CREATE FUNCTION run_function(function_id SMALLINT, attribute TEXT, listing JSONB) RETURNS JSONB
    LANGUAGE plpgsql
AS
$$
BEGIN
    RETURN run_function((SELECT function FROM functions WHERE id = function_id), attribute, listing);
END;
$$;


CREATE FUNCTION update_listing_custom_attributes(willhaben_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 attribute_ids SMALLINT[] DEFAULT NULL::SMALLINT[],
                                                 listing_ids INTEGER[] DEFAULT NULL::INTEGER[],
                                                 function_ids SMALLINT[] DEFAULT NULL::SMALLINT[]) RETURNS VOID
    LANGUAGE plpgsql
AS
$$
BEGIN

    INSERT INTO listing_custom_attributes(listing_id, attribute_id, values)
    SELECT l.id, ca.id, run_function(ca.function_id, '', l.raw)
    FROM listings l
             CROSS JOIN custom_attributes ca
    WHERE (willhaben_ids IS NULL OR l.willhaben_id = ANY (willhaben_ids))
      AND (attribute_ids IS NULL OR ca.id = ANY (attribute_ids))
      AND (listing_ids IS NULL OR l.id = ANY (listing_ids))
      AND (function_ids IS NULL OR ca.function_id = ANY (function_ids));
END;
$$;


CREATE FUNCTION listing_path_query(listing JSONB, path TEXT) RETURNS JSONB
    IMMUTABLE
    LANGUAGE plpgsql
AS
$$
DECLARE
    ret JSONB;
BEGIN
    SELECT coalesce(u.val, c.val, b.val)
    INTO ret
    FROM jsonb_path_query(listing, ('$.user.' || path)::JSONPATH) WITH ORDINALITY u(val, idx)
             FULL JOIN jsonb_path_query(listing, ('$.custom.' || path)::JSONPATH) WITH ORDINALITY c(val, idx)
                       USING (idx)
             FULL JOIN jsonb_path_query(listing, ('$.base.' || path)::JSONPATH) WITH ORDINALITY b(val, idx)
                       USING (idx)
    LIMIT 1;

    RETURN ret;
END
$$;


INSERT INTO watch_lists (url)
VALUES ('https://www.willhaben.at/iad/immobilien/eigentumswohnung/steiermark?a');
INSERT INTO watch_lists (url)
VALUES ('https://www.willhaben.at/iad/immobilien/haus-kaufen/steiermark?a');

